---
source: crates/bootstrap/src/lib.rs
expression: "postcompile::compile!\n{\n    use std::sync::Arc; use scuffle_bootstrap::main; struct TestGlobal; impl\n    scuffle_signal::SignalConfig for TestGlobal {} impl\n    scuffle_bootstrap::global::GlobalWithoutConfig for TestGlobal\n    { async fn init() -> anyhow::Result<Arc<Self>> { Ok(Arc::new(Self)) } }\n    struct MySvc; impl scuffle_bootstrap::service::Service<TestGlobal> for\n    MySvc\n    {\n        async fn run(self, _: Arc<TestGlobal>, _: scuffle_context::Context) ->\n        anyhow::Result<()> { println!(\"running\"); Ok(()) }\n    } main! { TestGlobal { scuffle_signal::SignalSvc, MySvc, } }\n}"
snapshot_kind: text
---
exit status: 0
--- stdout 
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::sync::Arc;
use scuffle_bootstrap::main;
struct TestGlobal;
impl scuffle_signal::SignalConfig for TestGlobal {}
impl scuffle_bootstrap::global::GlobalWithoutConfig for TestGlobal {
    async fn init() -> anyhow::Result<Arc<Self>> {
        Ok(Arc::new(Self))
    }
}
struct MySvc;
impl scuffle_bootstrap::service::Service<TestGlobal> for MySvc {
    async fn run(
        self,
        _: Arc<TestGlobal>,
        _: scuffle_context::Context,
    ) -> anyhow::Result<()> {
        {
            ::std::io::_print(format_args!("running\n"));
        };
        Ok(())
    }
}
#[automatically_derived]
fn main() -> ::scuffle_bootstrap::prelude::anyhow::Result<()> {
    #[doc(hidden)]
    pub const fn impl_global<G: ::scuffle_bootstrap::global::Global>() {}
    const _: () = impl_global::<TestGlobal>();
    ::scuffle_bootstrap::prelude::anyhow::Context::context(
        <TestGlobal as ::scuffle_bootstrap::global::Global>::pre_init(),
        "pre_init",
    )?;
    let runtime = <TestGlobal as ::scuffle_bootstrap::global::Global>::tokio_runtime();
    let config = ::scuffle_bootstrap::prelude::anyhow::Context::context(
        runtime
            .block_on(
                <<TestGlobal as ::scuffle_bootstrap::global::Global>::Config as ::scuffle_bootstrap::config::ConfigParser>::parse(),
            ),
        "config parse",
    )?;
    let ctx_handle = ::scuffle_bootstrap::prelude::scuffle_context::Handler::global();
    let mut shared_global = ::core::option::Option::None;
    let mut services_vec = ::std::vec::Vec::<
        ::scuffle_bootstrap::service::NamedFuture<
            ::scuffle_bootstrap::prelude::tokio::task::JoinHandle<anyhow::Result<()>>,
        >,
    >::new();
    let result = runtime
        .block_on(async {
            let global = <TestGlobal as ::scuffle_bootstrap::global::Global>::init(
                    config,
                )
                .await?;
            shared_global = ::core::option::Option::Some(global.clone());
            {
                #[doc(hidden)]
                pub async fn spawn_service(
                    svc: impl ::scuffle_bootstrap::service::Service<TestGlobal>,
                    global: &::std::sync::Arc<TestGlobal>,
                    ctx_handle: &::scuffle_bootstrap::prelude::scuffle_context::Handler,
                    name: &'static str,
                ) -> anyhow::Result<
                    Option<
                        ::scuffle_bootstrap::service::NamedFuture<
                            ::scuffle_bootstrap::prelude::tokio::task::JoinHandle<
                                anyhow::Result<()>,
                            >,
                        >,
                    >,
                > {
                    let name = ::scuffle_bootstrap::service::Service::<
                        TestGlobal,
                    >::name(&svc)
                        .unwrap_or_else(|| name);
                    if ::scuffle_bootstrap::prelude::anyhow::Context::context(
                        ::scuffle_bootstrap::service::Service::<
                            TestGlobal,
                        >::enabled(&svc, &global)
                            .await,
                        name,
                    )? {
                        Ok(
                            Some(
                                ::scuffle_bootstrap::service::NamedFuture::new(
                                    name,
                                    ::scuffle_bootstrap::prelude::tokio::spawn(
                                        ::scuffle_bootstrap::service::Service::<
                                            TestGlobal,
                                        >::run(svc, global.clone(), ctx_handle.context()),
                                    ),
                                ),
                            ),
                        )
                    } else {
                        Ok(None)
                    }
                }
                let res = spawn_service(
                        scuffle_signal::SignalSvc,
                        &global,
                        &ctx_handle,
                        "scuffle_signal :: SignalSvc",
                    )
                    .await;
                if let Some(spawned) = res? {
                    services_vec.push(spawned);
                }
            }
            {
                #[doc(hidden)]
                pub async fn spawn_service(
                    svc: impl ::scuffle_bootstrap::service::Service<TestGlobal>,
                    global: &::std::sync::Arc<TestGlobal>,
                    ctx_handle: &::scuffle_bootstrap::prelude::scuffle_context::Handler,
                    name: &'static str,
                ) -> anyhow::Result<
                    Option<
                        ::scuffle_bootstrap::service::NamedFuture<
                            ::scuffle_bootstrap::prelude::tokio::task::JoinHandle<
                                anyhow::Result<()>,
                            >,
                        >,
                    >,
                > {
                    let name = ::scuffle_bootstrap::service::Service::<
                        TestGlobal,
                    >::name(&svc)
                        .unwrap_or_else(|| name);
                    if ::scuffle_bootstrap::prelude::anyhow::Context::context(
                        ::scuffle_bootstrap::service::Service::<
                            TestGlobal,
                        >::enabled(&svc, &global)
                            .await,
                        name,
                    )? {
                        Ok(
                            Some(
                                ::scuffle_bootstrap::service::NamedFuture::new(
                                    name,
                                    ::scuffle_bootstrap::prelude::tokio::spawn(
                                        ::scuffle_bootstrap::service::Service::<
                                            TestGlobal,
                                        >::run(svc, global.clone(), ctx_handle.context()),
                                    ),
                                ),
                            ),
                        )
                    } else {
                        Ok(None)
                    }
                }
                let res = spawn_service(MySvc, &global, &ctx_handle, "MySvc").await;
                if let Some(spawned) = res? {
                    services_vec.push(spawned);
                }
            }
            macro_rules! handle_service_exit {
                ($remaining:ident) => {
                    { let ((name, result), _, remaining) =
                    ::scuffle_bootstrap::prelude::futures::future::select_all($remaining)
                    . await; let result =
                    ::scuffle_bootstrap::prelude::anyhow::Context::context(::scuffle_bootstrap::prelude::anyhow::Context::context(result,
                    name) ?, name); < TestGlobal as ::scuffle_bootstrap::global::Global >
                    ::on_service_exit(& global, name, result). await ?; remaining }
                };
            }
            let mut remaining = {
                let ((name, result), _, remaining) = ::scuffle_bootstrap::prelude::futures::future::select_all(
                        services_vec,
                    )
                    .await;
                let result = ::scuffle_bootstrap::prelude::anyhow::Context::context(
                    ::scuffle_bootstrap::prelude::anyhow::Context::context(
                        result,
                        name,
                    )?,
                    name,
                );
                <TestGlobal as ::scuffle_bootstrap::global::Global>::on_service_exit(
                        &global,
                        name,
                        result,
                    )
                    .await?;
                remaining
            };
            while !remaining.is_empty() {
                remaining = {
                    let ((name, result), _, remaining) = ::scuffle_bootstrap::prelude::futures::future::select_all(
                            remaining,
                        )
                        .await;
                    let result = ::scuffle_bootstrap::prelude::anyhow::Context::context(
                        ::scuffle_bootstrap::prelude::anyhow::Context::context(
                            result,
                            name,
                        )?,
                        name,
                    );
                    <TestGlobal as ::scuffle_bootstrap::global::Global>::on_service_exit(
                            &global,
                            name,
                            result,
                        )
                        .await?;
                    remaining
                };
            }
            ::scuffle_bootstrap::prelude::anyhow::Ok(())
        });
    let ::core::option::Option::Some(global) = shared_global else {
        return result;
    };
    runtime
        .block_on(
            <TestGlobal as ::scuffle_bootstrap::global::Global>::on_exit(&global, result),
        )
}
